{"version":3,"sources":["../../src/lib/FrameStream.js"],"names":["FrameStream","Transform","constructor","delay","file","repeatCount","Infinity","objectMode","encodeStream","GIFEncoder","setup","i","_transform","frame","enc","next","LOG","outputStream","getOutputStream","on","push","error","pipe","err","emit","addFrame","write","pixels","_end","end"],"mappings":";;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA;AACA;AACA,MAAMA,WAAN,SAA0BC,SAA1B,CAAoC;AAClCC,cAAY;AACVC,SADU;AAEVC,QAFU;AAGVC,kBAAcC;AAHJ,GAAZ,EAIG;AACD,UAAM;AACJC,kBAAY;AADR,KAAN;AAGA,SAAKJ,KAAL,GAAaA,KAAb;AACA,SAAKK,YAAL,GAAoB,IAAIC,UAAJ,CAAe;AACjCJ;AADiC,KAAf,CAApB;AAGA,SAAKK,KAAL,GAAa,KAAb;AACA,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKO,CAAL,GAAS,CAAT;AACD;;AACDC,aAAWC,KAAX,EAAkBC,GAAlB,EAAuBC,IAAvB,EAA6B;AAC3B,QAAI,CAAC,KAAKL,KAAV,EAAiB;AACfM,UAAI,0BAAJ;AAEA,YAAMC,eAAeC,gBAAgB,KAAKd,IAArB,EAClBe,EADkB,CACf,OADe,EACN,MAAM;AACjB,aAAKC,IAAL,CAAU,IAAV;AACD,OAHkB,EAIlBD,EAJkB,CAIf,OAJe,EAILE,KAAD,IAAW;AACtBN,aAAKM,KAAL;AACD,OANkB,CAArB;AAQA,WAAKb,YAAL,CAAkBc,IAAlB,CAAuBL,YAAvB;AAEA,WAAKT,YAAL,CACGW,EADH,CACM,OADN,EACgBI,GAAD,IAAS;AACpBR,aAAKQ,GAAL;AACD,OAHH,EAIGJ,EAJH,CAIM,WAJN,EAImB,MAAM;AACrBH,YAAI,gBAAJ;AACA,aAAKQ,IAAL,CAAU,WAAV,EAAuB,KAAKb,CAA5B;AACA,aAAKA,CAAL;AACAI;AACD,OATH;AAWA,WAAKL,KAAL,GAAa,IAAb;AACD;;AACDG,UAAMV,KAAN,GAAc,KAAKA,KAAnB;AACA,SAAKK,YAAL,CAAkBiB,QAAlB,CAA2BZ,KAA3B;AACAG,QAAI,kBAAJ,EAAwB,KAAKL,CAA7B;AACA,SAAKH,YAAL,CAAkBkB,KAAlB,CAAwBb,MAAMc,MAA9B;AACD;;AACDC,SAAO;AACL,QAAI,CAAC,KAAKlB,KAAV,EAAiB;AACjB,SAAKF,YAAL,CAAkBqB,GAAlB;AACD;;AApDiC","sourcesContent":["\n/**\n * update decoder:\n\n  for (var i = 0; i < scanline.length; i++) {\n    const val = scanline[i]\n    if (val == this._frame.transparentColor) {\n      res[p++] = -1\n      res[p++] = -1\n      res[p++] = -1\n    } else {\n      var idx = scanline[i] * 3;\n      res[p++] = this._palette[idx];\n      res[p++] = this._palette[idx + 1];\n      res[p++] = this._palette[idx + 2];\n    }\n  }\n\n  update encoder:\n\n  GIFEncoder.prototype._writeGCE = function(frame) {\n    var buf = new Buffer(8);\n    var delay = (frame.delay || 50) / 10 | 0;\n    var tc = frame.transparentColor || 0\n\n    buf[0] = 0x21;               // extension block\n    buf[1] = 0xf9;               // graphic control extension\n    buf[2] = 4;                  // block size\n    buf[3] = 0;                  // flags\n    buf.writeUInt16LE(delay, 4); // frame delay\n    buf[6] = tc;                 // transparent color index\n    buf[7] = 0;                  // block terminator\n\n    this.push(buf);\n  };\n\n */\n\n\n/* eslint-disable */\n// unused\nclass FrameStream extends Transform {\n  constructor({\n    delay,\n    file,\n    repeatCount = Infinity,\n  }) {\n    super({\n      objectMode: true,\n    })\n    this.delay = delay\n    this.encodeStream = new GIFEncoder({\n      repeatCount,\n    })\n    this.setup = false\n    this.file = file\n    this.i = 1\n  }\n  _transform(frame, enc, next) {\n    if (!this.setup) {\n      LOG('Setting up encode stream')\n\n      const outputStream = getOutputStream(this.file)\n        .on('close', () => {\n          this.push(null)\n        })\n        .on('error', (error) => {\n          next(error)\n        })\n\n      this.encodeStream.pipe(outputStream)\n\n      this.encodeStream\n        .on('error', (err) => {\n          next(err)\n        })\n        .on('end frame', () => {\n          LOG('written pixels')\n          this.emit('end frame', this.i)\n          this.i++\n          next()\n        })\n\n      this.setup = true\n    }\n    frame.delay = this.delay\n    this.encodeStream.addFrame(frame)\n    LOG('writing frame %s', this.i)\n    this.encodeStream.write(frame.pixels)\n  }\n  _end() {\n    if (!this.setup) return\n    this.encodeStream.end()\n  }\n}\n"],"file":"FrameStream.js"}